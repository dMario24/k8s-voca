"""k8s_voca 모듈.

K8s Voca Search and Output

Example:
    ``k8s_voca`` 사용법은 아래와 같습니다.

        $ pip install ./
        $ kv container
"""
import sys

K8sVoca = {

    "Container": """실행하는 각 컨테이너는 반복 가능하다. 의존성이 포함된 표준화는 어디에서 실행하던지 동일한 동작을 얻는다는 것을 의미한다.
컨테이너는 기본 호스트 인프라에서 애플리케이션을 분리한다. 따라서 다양한 클라우드 또는 OS 환경에서 보다 쉽게 배포할 수 있다.
쿠버네티스 클러스터에 있는 개별 node는 해당 노드에 할당된 파드를 구성하는 컨테이너들을 실행한다.
파드 내부에 컨테이너들은 같은 노드에서 실행될 수 있도록 같은 곳에 위치하고 함께 스케줄된다.""",
    "컨테이너": """실행하는 각 컨테이너는 반복 가능하다. 의존성이 포함된 표준화는 어디에서 실행하던지 동일한 동작을 얻는다는 것을 의미한다.
컨테이너는 기본 호스트 인프라에서 애플리케이션을 분리한다. 따라서 다양한 클라우드 또는 OS 환경에서 보다 쉽게 배포할 수 있다.
쿠버네티스 클러스터에 있는 개별 node는 해당 노드에 할당된 파드를 구성하는 컨테이너들을 실행한다.
파드 내부에 컨테이너들은 같은 노드에서 실행될 수 있도록 같은 곳에 위치하고 함께 스케줄된다.""",

    "Pod": "쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.(하나이상의 컨테이너 그룹)",
    "pods": "쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.(하나이상의 컨테이너 그룹)",

    "ReplicaSet": "레플리카셋의 목적은 레플리카 파드 집합의 실행을 항상 안정적으로 유지하는 것이다. 레플리카셋은 보통 명시된 동일 파드 개수에 대한 가용성을 보증하는데 사용한다.",

    "Deployment": "파드와 레플리카셋(ReplicaSet)에 대한 선언적 업데이트를 제공한다. 클러스터의 스테이트리스 애플리케이션 워크로드를 관리하기에 적합하다.",
    "deployments": "파드와 레플리카셋(ReplicaSet)에 대한 선언적 업데이트를 제공한다. 클러스터의 스테이트리스 애플리케이션 워크로드를 관리하기에 적합하다.",

    "StatefulSet": "어떻게든 스테이트(state)를 추적하는 하나 이상의 파드를 동작하게 해준다. 예를 들면, 워크로드가 데이터를 지속적으로 기록하는 경우, 사용자는 Pod 와 PersistentVolume을 연계하는 StatefulSet 을 실행할 수 있다. 전체적인 회복력 향상을 위해서, StatefulSet 의 Pods 에서 동작 중인 코드는 동일한 StatefulSet 의 다른 Pods 로 데이터를 복제할 수 있다.",
    "DaemonSet": "노드-로컬 기능(node-local facilities)을 제공하는 Pods 를 정의한다. 이러한 기능들은 클러스터를 운용하는 데 기본적인 것일 것이다. 예를 들면, 네트워킹 지원 도구 또는 add-on 등이 있다. DaemonSet 의 명세에 맞는 노드를 클러스터에 추가할 때마다, 컨트롤 플레인은 해당 신규 노드에 DaemonSet 을 위한 Pod 를 스케줄한다.",
    "Job": "단 한번만 실행 완료 후 중단되는 작업을 정의",
    "CronJob": "스케줄에 따라 반복되고 실행 완료 후 중단되는 작업을 정의",
    "Static Pod": "스태틱 파드는API 서버없이 특정 노드에 있는 kubelet 데몬에 의해 직접 관리된다. 컨트롤 플레인에 의해 관리되는 파드(예를 들어디플로이먼트(Deployment))와는 달리, kubelet 이 각각의 스태틱 파드를 감시한다. (만약 실패할 경우 다시 구동한다.)",

    "노드": "쿠버네티스는 컨테이너를 파드내에 배치하고 노드 에서 실행함으로 워크로드를 구동한다. 노드는 클러스터에 따라 가상(EC2) 또는 물리적 머신일 수 있다.",
    "node": "쿠버네티스는 컨테이너를 파드내에 배치하고 노드 에서 실행함으로 워크로드를 구동한다. 노드는 클러스터에 따라 가상(EC2) 또는 물리적 머신일 수 있다.",

    "Control": "컨트롤 플레인은 워커 노드와 클러스터 내 파드를 관리한다.",
    "Control Plane": "컨트롤 플레인은 워커 노드와 클러스터 내 파드를 관리한다.",
    "컨트롤 플레인": "컨트롤 플레인은 워커 노드와 클러스터 내 파드를 관리한다.",
    "마스터 노드": "컨트롤 플레인은 워커 노드와 클러스터 내 파드를 관리한다.",

    "Data Plane": "워커 노드는 애플리케이션의 구성요소인 파드를 호스트한다.",
    "데이타 플레인(워커 노드)": "워커 노드는 애플리케이션의 구성요소인 파드를 호스트한다.",

    "ConfigMap": "컨피그맵은 키-값 쌍으로 기밀이 아닌 데이터를 저장",
    "컨피그맵": "컨피그맵은 키-값 쌍으로 기밀이 아닌 데이터를 저장",

    "Secret": "암호, 토큰 또는 키와 같은 소량의 중요한 데이터를 포함하는 오브젝트",

    "서비스": "파드 집합에서 실행중인 애플리케이션을 네트워크 서비스로 노출하는 추상화 방법",
    "services": "파드 집합에서 실행중인 애플리케이션을 네트워크 서비스로 노출하는 추상화 방법",
    "service": "파드 집합에서 실행중인 애플리케이션을 네트워크 서비스로 노출하는 추상화 방법",

    "네임스페이스": """네임스페이스는 여러 개의 팀이나, 프로젝트에 걸쳐서 많은 사용자가 있는 환경에서 사용하도록 만들어졌다. 
사용자가 거의 없거나, 수 십명 정도가 되는 경우에는 네임스페이스를 전혀 고려할 필요가 없다.
네임스페이스가 제공하는 기능이 필요할 때 사용하도록 하자.

쿠버네티스에서, 네임스페이스 는 단일 클러스터 내에서의 리소스 그룹 격리 메커니즘을 제공한다.
리소스의 이름은 네임스페이스 내에서 유일해야 하며, 네임스페이스 간에서 유일할 필요는 없다.
네임스페이스 기반 스코핑은 네임스페이스 기반 오브젝트 (예: 디플로이먼트, 서비스 등) 에만 적용 가능하며 클러스터 범위의 오브젝트 (예: 스토리지클래스, 노드, 퍼시스턴트볼륨 등) 에는 적용 불가능하다.""",
    "Namespaces": """네임스페이스는 여러 개의 팀이나, 프로젝트에 걸쳐서 많은 사용자가 있는 환경에서 사용하도록 만들어졌다. 
사용자가 거의 없거나, 수 십명 정도가 되는 경우에는 네임스페이스를 전혀 고려할 필요가 없다.
네임스페이스가 제공하는 기능이 필요할 때 사용하도록 하자.

쿠버네티스에서, 네임스페이스 는 단일 클러스터 내에서의 리소스 그룹 격리 메커니즘을 제공한다.
리소스의 이름은 네임스페이스 내에서 유일해야 하며, 네임스페이스 간에서 유일할 필요는 없다.
네임스페이스 기반 스코핑은 네임스페이스 기반 오브젝트 (예: 디플로이먼트, 서비스 등) 에만 적용 가능하며 클러스터 범위의 오브젝트 (예: 스토리지클래스, 노드, 퍼시스턴트볼륨 등) 에는 적용 불가능하다.""",

}


def ping():
    """K8s Voca Search and Output
    """
    if len(sys.argv) > 1:
        query = sys.argv[1]

        for word, meaning in K8sVoca.items():
            if word.lower() == query.lower():
                print(f'>> {meaning}')
    else:
        for word, meaning in K8sVoca.items():
            print(f'{word}: {meaning}')


if __name__ == "__main__":
    ping()
